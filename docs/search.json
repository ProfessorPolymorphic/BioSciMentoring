[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BIOLOGICAL SCIENCES // MENTORING",
    "section": "",
    "text": "The Department of Biological Sciences is considering a new system for advising and mentoring of undergraduate students. Under the new system, advising functions would be performed by full time professional staff. Mentoring of students would be performed by department faculty. The purpose of this document is to outline the goals, structure, and requirements of the new mentoring system."
  },
  {
    "objectID": "index.html#program-goals",
    "href": "index.html#program-goals",
    "title": "BIOLOGICAL SCIENCES // MENTORING",
    "section": "PROGRAM GOALS",
    "text": "PROGRAM GOALS\n\nPromote students’ intellectual independence and curiosity.\nFoster students’ ability to make academic, research, and career decisions.\nHelp students clarify their career goals.\nPromote students’ sense of belonging as a member of a community of scholars in the department and college.\nHelp students build confidence."
  },
  {
    "objectID": "index.html#program-structure",
    "href": "index.html#program-structure",
    "title": "BIOLOGICAL SCIENCES // MENTORING",
    "section": "PROGRAM STRUCTURE",
    "text": "PROGRAM STRUCTURE\n\nFirst Year Experience Course\nWe are currently considering a 1 credit course required of all our majors. The course would be taught by Dr. Miura. The structure and content of the course are still unknown. The options for structure and content, and their associated pros and cons are listed below.\n\nCourse Structure\n\nSections?Timing?Transfers\n\n\nOne big section? Subgroups? By Major?\n\n\nTiming (does this occur before assignment?)\n\n\nChanging majors? Waive?\n\n\n\n\n\nCourse Content\nFaculty presentations. Beware the boring research lecture! Perhaps include material on career path. Other presentations (undergrad researchers, grad students, campus resources, etc)\nRequired\nSubstantive outreach experiences from the department? Interaction to build cohort bonding Attend a certain number of College events. Hogwarts style houses within the class."
  },
  {
    "objectID": "index.html#mentor-assignment",
    "href": "index.html#mentor-assignment",
    "title": "BIOLOGICAL SCIENCES // MENTORING",
    "section": "MENTOR ASSIGNMENT",
    "text": "MENTOR ASSIGNMENT\n\nHow many students?\nBelow are the enrollment data for the five degrees offered in the Department of Biological Sciences. Note that these data include double majors, and so might not be a completely accurate estimate of the number of unique students requiring a mentor.\n\n\n\n\n\n\n\n\n\nEnrollment by Degree, Year, and Class\n\n\n\n\n\n\n\nTotal Department Enrollment\n\n\n\n\n\n\nEnrollment data for the Department of Biological Sciences.\n\n\n\nThere are two primary take home messages:\nFirst, we have 397 students within across our majors who will be assigned to mentors.\nSecond, more than half of those students (216) are Medical Science majors.\n\n\nHow many faculty?\nThere are 30 faculty listed on our faculty web page. If we assume each faculty member is assigned an equal number of mentees, we get 13 mentees per faculty.\nOf course, our assumption of equal assignment across faculty isn’t really feasible for many good reasons. We should probably remove the following faculty from our list of eligblie mentors:\n\nGinger Carney is pretty busy being Dean of the College of Science.\nLisa Bird, Mary Oswald, and Candi Heimgartner are Senior Intstructors who do not normally advise students.\nNicole Grieshaber is research faculty.\nLarry Forney and Eva Top have emeritus appointments.\n\nThis brings us down to 23 eligible faculty with about 17 mentees each.\nIn addition, I am not sure about the following faculty members’ potential roles in the mentoring program:\n\nShirley Luckhart has a joint appointment in CALS and her mentoring effort might be deployed there.\nTanya Miura is department chair and is also slated to teach the freshman experience course.\nJim Bull and Holly Wichman may have partial appointments?\n\nThis gets us to somewhere between 19 and 23 eligible mentors, meaning we should plan for between 17 and 20 per faculty member.\n\n\nOptions for matching\nHow will mentees be assigned to mentors? When they were advisees, it was largely an ad hoc system shaped somewhat by the student’s major. All of us had a mixture of advisees that aspired to careers as health professionals, researchers, technicians, and … undefined …\nNow, more than half of our students are Medical Science majors.\nSome methods for matching mentees and mentors include:\n\nSurveys and Clustering. Collect survey data from students and faculty about their academic/research interests. Use these data to cluster people into groups. Then use this information to guide (loosely or definitively) the matching process. Collecting this survey information from students would likely have other interesting applications. Obvious drawbacks include the amount of work to create and analyze the survey and controlling the response rate.\nFirst come - First served. Allow students to sign up for the mentor of their choice. Establish a cap for each mentor. I don’t see many advantages to this system. Disadvantages include the amount of work to set up the sign up system and the “competence penalty” imposed on the faculty that have somehow resonated with lots of students.\n\nRandom. Almost no work. Sometimes the simplest choice makes a lot of sense…\nRanked Choice. This could be combined with option 1, but is probably a fair amount of work to set up.\n\nThere are some visualizations and online tools that could use the data from option 1 to help us understand our department and our students. They also might make it easier for students to find undergraduate research mentors. They also might make our department look cool when we try to recruit students.\n\nx = d3.scalePoint(attributes, [margin.left, width - margin.right])\n\ny = {\n  let scales = new Map();\n\n  attributes.forEach(function(attribute) {\n    //only attribute origin is ordinal data and needs a different scale\n    if (attribute == \"origin\"){\n      scales.set(\n        attribute,\n        //https://observablehq.com/@sophiegri/exercise-2-scatterplot-matrix\n        //d3.extent gets min and max value of the given attribute \n        //3 attributes for origin so axis needs to be cut in half\n        d3.scaleOrdinal().range([height - margin.bottom, height/2, margin.top])\n          .domain(d3.extent(data, item => item[attribute]))\n      );\n    } \n    else {\n      scales.set(\n        attribute,\n        //d3.extent gets min and max value of the given attribute \n        d3.scaleLinear().range([height - margin.bottom, margin.top])\n          .domain(d3.extent(data, item => item[attribute]))\n      );\n    }      \n  });\n\n  return scales;\n}\n\nviewof colorAttribute = select({\n  title: \"Color Attribute\",\n  description: \"Pick an attribute for coloring the polylines.\",\n  options: attributes,\n  value: \"origin\"\n})\n\n//https://observablehq.com/@sophiegri/exercise-2-scatterplot-matrix\ncolor = d3.scaleOrdinal(d3.schemeTableau10)\n\nparacoords = {\n  const svg = d3.create(\"svg\").attr(\"viewBox\", [0, 0, width, height]);\n\n  // set the style of hidden data items\n  svg\n    .append(\"style\")\n    .text(\"path.hidden { stroke: #000; stroke-opacity: 0.01;}\");\n\n  // a map that holds any active brush per attribute\n  let activeBrushes = new Map();\n\n  const polylines = svg\n    .append(\"g\")\n    .attr(\"fill\", \"none\")\n    .attr(\"stroke-width\", 1.5)\n    .attr(\"stroke-opacity\", 0.4)\n    .selectAll(\"path\")\n    .data(data)\n    .join(\"path\")  \n    //paint the polylines\n    //https://observablehq.com/@sophiegri/exercise-2-scatterplot-matrix\n    .attr(\"stroke\", d => color(d[colorAttribute]))\n    //set the lines\n    //https://observablehq.com/@d3/parallel-coordinates\n    .attr(\"d\", d => d3.line()\n          .defined(([, value]) => value != null)\n          .y(([key, value]) => y.get(key)(value))\n          .x(([key]) => x(key))\n        (d3.cross(attributes, [d], (key, d) => [key, d[key]])));\n\n  // create the group nodes for the axes\n  const axes = svg\n    .append(\"g\")\n    .selectAll(\"g\")\n    .data(attributes)\n    .join(\"g\")    \n    .attr(\"transform\", d => `translate(${x(d)},0)`)\n    //https://observablehq.com/@d3/parallel-coordinates\n    //set axis to the right and set the text\n    .each(function(d) { d3.select(this).call(d3.axisRight(y.get(d))); })\n    .call(g => g.append(\"text\")\n        //position of the text \n        .attr(\"x\", -1)\n        .attr(\"y\", 7.5)\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"fill\", \"currentColor\")\n        //.get(d) gets the short name (value) from the Map shortAttributeNames\n        .text(d => shortAttributeNames.get(d)));\n \n\n  function updateBrushing() {    \n    var number_brushes = activeBrushes.size;\n    if (number_brushes == 0) {\n      //false is colored, true is hidden\n      polylines.classed(\"hidden\", d => {return false});\n    } \n    else {\n      polylines.classed(\"hidden\", d => {\n        var return_value = false; \n        //iterate over Map and get y-values\n        activeBrushes.forEach((value, key) => {\n          var y0 = value[0]; \n          var y1 = value[1];\n          //check if car value is inside an active brush\n          var value_y = y.get(key)(d[key]);\n          if (value_y <= y1 && value_y >= y0) {\n          } \n          else {\n              return_value=true;\n          }   \n        });\n        //variable to see the active polylines in this scope\n        return return_value;\n     });\n    }                       \n  }\n\n  function brushed(attribute) {\n    activeBrushes.set(attribute, d3.event.selection);\n    updateBrushing();\n  }\n\n  function brushEnd(attribute) {\n    if (d3.event.selection !== null) return;\n    activeBrushes.delete(attribute);\n    updateBrushing();\n  }\n\n  const brushes = axes.append(\"g\").call(\n    d3\n      .brushY()\n      .extent([[-10, margin.top], [10, height - margin.bottom]])\n      .on(\"brush\", brushed)\n      .on(\"end\", brushEnd)\n  );\n\n  return svg.node();\n}\n\n\nheight = 1500\n\nmargin = ({ top: 10, right: 30, bottom: 10, left: 10 })\n\ndata = d3.csvParse(await FileAttachment(\"cars.csv\").text(), d3.autoType)\n\nattributes = data.columns.filter(d => d !== \"name\")\n\nshortAttributeNames = new Map(\n  Object.entries({\n    mpg: \"MPG\",\n    cylinders: \"CYL\",\n    displacement: \"DPL\",\n    horsepower: \"HP\",\n    weight: \"WGT\",\n    acceleration: \"ACL\",\n    year: \"YEAR\",\n    origin: \"OGN\"\n  })\n)\n\nimport { select } from \"@jashkenas/inputs\"\n\nd3 = require(\"d3@5\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFluidity of Assignments\nOne suggestion that came up in almost every faculty interview was the notion of mentees changing mentors. For example, when a student joins a lab for undergraduate research, it is very likely that the supervising research mentor would become the assigned mentor. When a student discovers their passion and changes their career plans, they should be able to look for a mentor that can help them achieve their new goals."
  },
  {
    "objectID": "index.html#roles-and-responsibilities",
    "href": "index.html#roles-and-responsibilities",
    "title": "BIOLOGICAL SCIENCES // MENTORING",
    "section": "ROLES AND RESPONSIBILITIES",
    "text": "ROLES AND RESPONSIBILITIES\n\nMentors\nOne of the key program components we have yet to define is the set of minimum requirements for the mentors. Some important unanswered questions include:\n\nHow many hours per week is “mentoring”? This has always varied across faculty, and always will. Nevertheless, is there a minimum expectation?\nDoes everyone have to do the same thing? After the freshman experience class, can each mentor establish their own approach / schedule / requirements?\n\nRequired vs Optional? Are meetings required? How often? How is this enforced? If they are not required, are we reaching the students that really need the help?\nHow is it tracked? Once things are required, then they need to be tracked. Who will do this? How will they do it?\nAccountability? Assessment? How do we know if the program is working? How do we know if mentors are meeting expectations? If some are not performing, is there any mechanism for accountability?\n“Credit”? How is this refelected in the position description? Is this system another unfunded mandate?\n\n\n\nMentees\nMentoring works best when both parties are engaged. How do we incentivize mentee engagement? What are we asking mentees to do as part of this process?\n\nDo they have to show up or engage? The students who aren’t engaged are the ones with the biggest retention problems (… he asserted without evidence…)\nClarify goals: explain to your mentor what you want from your career, and from the mentoring program.\nCome prepared: set up an agenda ahead of meetings and give your mentor enough time in advance to review any materials.\nIs it the student’s responsibility to keep the relationship going?\nRespect boundaries. Create upfront agreements about what to do if time-sensitive issues arise outside your organized meetings.\nTake action between sessions.\nProvide feedback."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "storage.html",
    "href": "storage.html",
    "title": "storage",
    "section": "",
    "text": "selection\n\n\n\n\n\n\n\nviewof keyz = {\n  const form = html`<form>${Object.assign(html`<select name=select>${keys.map(key => Object.assign(html`<option>`, {value: key, textContent: key}))}</select>`, {value: \"weight (lb)\"})} <i style=\"font-size:smaller;\">color encoding</i>`;\n  form.select.onchange = () => (form.value = form.select.value, form.dispatchEvent(new CustomEvent(\"input\")));\n  form.select.onchange();\n  return form;\n}\nlegend = Legend({color: z, title: keyz})\n\nviewof selection = {\n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [0, 0, width, height]);\n\n  const brush = d3.brushX()\n      .extent([\n        [margin.left, -(brushHeight / 2)],\n        [width - margin.right, brushHeight / 2]\n      ])\n      .on(\"start brush end\", brushed);\n\n  const path = svg.append(\"g\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke-width\", 1.5)\n      .attr(\"stroke-opacity\", 0.4)\n    .selectAll(\"path\")\n    .data(data.slice().sort((a, b) => d3.ascending(a[keyz], b[keyz])))\n    .join(\"path\")\n      .attr(\"stroke\", d => z(d[keyz]))\n      .attr(\"d\", d => line(d3.cross(keys, [d], (key, d) => [key, d[key]])));\n\n  path.append(\"title\")\n      .text(label);\n\n  svg.append(\"g\")\n    .selectAll(\"g\")\n    .data(keys)\n    .join(\"g\")\n      .attr(\"transform\", d => `translate(0,${y(d)})`)\n      .each(function(d) { d3.select(this).call(d3.axisBottom(x.get(d))); })\n      .call(g => g.append(\"text\")\n        .attr(\"x\", margin.left)\n        .attr(\"y\", -6)\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"fill\", \"currentColor\")\n        .text(d => d))\n      .call(g => g.selectAll(\"text\")\n        .clone(true).lower()\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke-width\", 5)\n        .attr(\"stroke-linejoin\", \"round\")\n        .attr(\"stroke\", \"white\"))\n      .call(brush);\n\n  const selections = new Map();\n\n  function brushed({selection}, key) {\n    if (selection === null) selections.delete(key);\n    else selections.set(key, selection.map(x.get(key).invert));\n    const selected = [];\n    path.each(function(d) {\n      const active = Array.from(selections).every(([key, [min, max]]) => d[key] >= min && d[key] <= max);\n      d3.select(this).style(\"stroke\", active ? z(d[keyz]) : deselectedColor);\n      if (active) {\n        d3.select(this).raise();\n        selected.push(d);\n      }\n    });\n    svg.property(\"value\", selected).dispatch(\"input\");\n  }\n\n  return svg.property(\"value\", data).node();\n}\n\n\ndata = FileAttachment(\"cars.csv\").csv({typed: true})\n\nkeys = data.columns.slice(1)\n\nx = new Map(Array.from(keys, key => [key, d3.scaleLinear(d3.extent(data, d => d[key]), [margin.left, width - margin.right])]))\n\ny = d3.scalePoint(keys, [margin.top, height - margin.bottom])\n\nz = d3.scaleSequential(x.get(keyz).domain().reverse(), colors)\n\nline = d3.line()\n    .defined(([, value]) => value != null)\n    .x(([key, value]) => x.get(key)(value))\n    .y(([key]) => y(key))\n    \nlabel = d => d.name\n\ncolors = d3.interpolateBrBG\n\ndeselectedColor = \"#ddd\"\n\nbrushHeight = 50\n\nmargin = ({top: 30, right: 10, bottom: 30, left: 10})\n\nheight = keys.length * 120\n\nd3 = require(\"d3@6\")\n\nimport {legend as Legend} from \"@d3/color-legend\""
  }
]